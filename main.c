/*!***************************************************
 * 测试程序
 * @param:
 * @return:
 * @note: 		开发过程中使用，代码完成后需要删除本函数
 ****************************************************/
#include <stdio.h>
#include <pthread.h>
#include <sys/time.h>
//#include <linux/delay.h>

#include "ifcan.h"

static u64  ifcanGetTimestampInS();

	
static u64  ifcanGetTimestampInS()
{
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return tv.tv_sec;
}


volatile struct timeval start, end;
int timeuse;
int a=0;
int b=0;
int c=0;
int d=0;
int e=0;
int f=0;
void *threadwhile1(void *arg)
{
	while (1)
		{
		a++;
		}

}

void *threadwhile2(void *arg)
{
	while (1)
		{
		b++;
		}

}
void *threadwhile3(void *arg)
{
	while (1)
		{
		c++;
		}

}
void *threadwhile4(void *arg)
{
	while (1)
		{
		d++;
		}

}

void *threadwhile5(void *arg)
{
	while (1)
		{
		e++;
		}

}

void *threadwhile6(void *arg)
{
	while (1)
		{
		f++;
		}

}



void *thread1IfcanSend(void *arg)
		{
			//u8 destId=0x2;
			u8 destId;
			u8 packageType=IFCAN_TYPE_CMD;
			u8 whichCan=*(u8 *)arg;

			unsigned char pData[]={0x00,0x00,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,
				0xDE,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,
				0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,
				0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,
				0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,
				0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,
				0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,
				0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,
				0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,
				0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,
				0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,
				0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,
				0x00,0x00,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,
				0xDE,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,
				0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,
				0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,
				0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,
				0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,
				0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,
				0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,
				0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,
				0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,
				0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,
				0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,
				0x00,0x00,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,
				0xDE,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,
				0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,
				0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,
				0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,
				0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,
				0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,
				0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,
				0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,
				0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,
				0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,
				0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,
				0x00,0x00,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,
				0xDE,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,
				0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,
				0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,
				0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,
				0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,
				0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,
				0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,
				0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,
				0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,
				0x9A,0xBC,0xDE,0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,
				0xF0,0xF0,0xAB,0x78,0x9A,0xBC,0xDE,0xF0,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0,};
		
			

			while(1)
			{ //	usleep(100000);
				gettimeofday(&start, NULL);
			
				if(whichCan==0)
				{
					destId=0x2;
					ifcanSend(whichCan,destId,packageType,pData,sizeof(pData));
				
				}
				else if(whichCan==1)
				{
					destId=0x1;
					ifcanSend(whichCan,destId,packageType,pData,sizeof(pData));
				}
				else
				{
					printf("wrong which=%d",whichCan);
				}

				sleep(3);
			}
	
		}


	void *thread2IfcanRecv(void *arg)
		{
			u8 whichCan=*(u8 *)arg;
	
			u16 funCodeList[2]={0xAB,0xCD};
	
			u32 ret;
	
			u8 sourceId;
			u8 packageType;
			u8 dataBuf[1024];
			u32 dataLength;
	
			u32 i;
			
			ret=ifcanMsgReg(whichCan,IFCAN_TYPE_CMD,funCodeList,2);
			if(ret!=0)
			{
				printf("ifcanMsgReg error! the error code is %d\r\n",ret);
			}
			
			while(1)
			{		
				ret=ifcanReceive(whichCan,&sourceId,&packageType,dataBuf,&dataLength,3);
	
				if(4==ret)
				{
					printf("**111111111*time out\r\n");
				}
				else if(0==ret)
				{
					printf("received data from id=%d,the 11111111111 receviced data are:\r\n",sourceId);
	
					for(i=0;i<dataLength;i++)
					{
						printf("%x ",dataBuf[i]);
					}
					
					printf("\r\n");
					
					
					//sleep(1);
				}
				else
				{
					printf("--------other error! the error code is %d\r\n",ret);
					//sleep(1);
				}
				gettimeofday(&end, NULL );
				timeuse = 1000000 * ( end.tv_sec - start.tv_sec ) + end.tv_usec - start.tv_usec; 
    			printf("***************************timeuse is : %d us \n", timeuse);
			//	printf("############   a  is %d \r\n",a);

			}
	
			
			
		}
	
	int main(void)
	{
		pthread_t pIfcanSend,pIfcanRecv,while1,while2,while3,while4,while5,while6;
		u8 whichCanUse0,whichCanUse1;
		u32 ret;
		whichCanUse0=CAN0;
		whichCanUse1=CAN1;
	
			IfcanConfiguration ifcanConfig;
	
			ifcanConfig.encryptEnable=0x1;//不加密
			ifcanConfig.validateEnable=0x0;
			ifcanConfig.sourceId=0x1;
			ifcanInit(CAN0,ifcanConfig);
	
			ifcanConfig.sourceId=0x2;
			ifcanInit(CAN1,ifcanConfig);
			
		
			
		//	sleep(3);
	
		
		//创建发送线程
		ret=pthread_create(&pIfcanSend,NULL,thread1IfcanSend,&whichCanUse0);

	//	ret=pthread_create(&while1,NULL,threadwhile1,NULL);
	//	ret=pthread_create(&while2,NULL,threadwhile2,NULL);
	//	ret=pthread_create(&while3,NULL,threadwhile3,NULL);
	//	ret=pthread_create(&while4,NULL,threadwhile4,NULL);
	//	ret=pthread_create(&while5,NULL,threadwhile5,NULL);
	//	ret=pthread_create(&while6,NULL,threadwhile6,NULL);
	//	ifcanConfig.sourceId=0x3;
	//	ifcanInit(CAN0,ifcanConfig);
	//	ret=pthread_create(&pIfcanSend,NULL,thread1IfcanSend,&whichCanUse0);

			
		//ret=pthread_create(&pIfcanSend,NULL,thread1IfcanSend,&whichCanUse1);
	
		//创建接收线程
		
		ret=pthread_create(&pIfcanRecv,NULL,thread2IfcanRecv,&whichCanUse1);
	


		while(1)
			sleep(1);
		return 0;
	}










